/*
 * Starlink Enterprise API
 *
 * <h3>Description</h3>API to manage accounts and user terminals. This page is deprecated, please use the new documentation site: <a href='https://starlink.readme.io/'>https://starlink.readme.io/</a><h3>Authentication - OIDC</h3><p>To authenticate with this API using OIDC, <a target='_blank' href='/api/auth/.well-known/openid-configuration'>Well Known URL</a> and attach the result to your requests with the <strong>Authorize</strong> button below.</p>
 *
 * The version of the OpenAPI document: 1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_batch_config_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersBatchConfigPutError {
    Status422(models::ServiceResponse),
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_configs_config_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersConfigsConfigIdGetError {
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_configs_config_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersConfigsConfigIdPutError {
    Status422(models::RouterConfigResponseServiceResponse),
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_configs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersConfigsGetError {
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_configs_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersConfigsPostError {
    Status422(models::RouterConfigResponseServiceResponse),
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_router_id_config_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersRouterIdConfigDeleteError {
    Status422(models::ServiceResponse),
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_router_id_config_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersRouterIdConfigPutError {
    Status422(models::ServiceResponse),
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_router_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersRouterIdGetError {
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_router_id_reboot_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersRouterIdRebootPostError {
    Status422(models::ServiceResponse),
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_sandbox_client_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersSandboxClientPostError {
    Status422(models::ServiceResponse),
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_sandbox_clients_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersSandboxClientsGetError {
    Status422(models::ServiceResponse),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_sandbox_clients_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersSandboxClientsPostError {
    Status422(models::ServiceResponse),
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_sandbox_heartbeat_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersSandboxHeartbeatPutError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_sandbox_sandbox_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersSandboxSandboxIdPutError {
    Status422(models::UpdateSandboxResponseServiceResponse),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_tls_config_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersTlsConfigDeleteError {
    Status422(models::TlsConfigPublicResponseServiceResponse),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_tls_config_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersTlsConfigPostError {
    Status422(models::TlsConfigPublicResponseServiceResponse),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_routers_tls_configs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberRoutersTlsConfigsGetError {
    Status422(models::TlsConfigPublicResponseServiceResponse),
    Status403(),
    UnknownValue(serde_json::Value),
}


/// Assign the config (or none) to the routers. For each router if it is currently online, the config will immediately be sent to the router.  Else, the config will be sent to the router when it comes online. Configs are sent to the router within 1-2 minutes. On error no assignment occurs.
pub async fn enterprise_v1_account_account_number_routers_batch_config_put(configuration: &configuration::Configuration, account_number: &str, update_batch_device_config_request: Option<models::UpdateBatchDeviceConfigRequest>) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersBatchConfigPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_update_batch_device_config_request = update_batch_device_config_request;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/batch-config", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_update_batch_device_config_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersBatchConfigPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// @permission [RequireCustomerPermission] feature:DeviceCommand, permission:View
pub async fn enterprise_v1_account_account_number_routers_configs_config_id_get(configuration: &configuration::Configuration, account_number: &str, config_id: &str) -> Result<models::RouterConfigResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersConfigsConfigIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_config_id = config_id;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/configs/{configId}", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), configId=crate::apis::urlencode(p_config_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RouterConfigResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RouterConfigResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersConfigsConfigIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a given router config. Any router assigned to this config will immediately receive the update if they are online.  Otherwise, the router will receive the update when it comes online.
pub async fn enterprise_v1_account_account_number_routers_configs_config_id_put(configuration: &configuration::Configuration, account_number: &str, config_id: &str, router_config_request: Option<models::RouterConfigRequest>) -> Result<models::RouterConfigResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersConfigsConfigIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_config_id = config_id;
    let p_router_config_request = router_config_request;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/configs/{configId}", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), configId=crate::apis::urlencode(p_config_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_router_config_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RouterConfigResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RouterConfigResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersConfigsConfigIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// @permission [RequireCustomerPermission] feature:DeviceCommand, permission:View
pub async fn enterprise_v1_account_account_number_routers_configs_get(configuration: &configuration::Configuration, account_number: &str, page: Option<i32>) -> Result<models::RouterConfigResponsePaginatedServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersConfigsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_page = page;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/configs", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RouterConfigResponsePaginatedServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RouterConfigResponsePaginatedServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersConfigsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// @permission [RequireCustomerPermission] feature:DeviceCommand, permission:Edit
pub async fn enterprise_v1_account_account_number_routers_configs_post(configuration: &configuration::Configuration, account_number: &str, router_config_request: Option<models::RouterConfigRequest>) -> Result<models::RouterConfigResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersConfigsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_router_config_request = router_config_request;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/configs", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_router_config_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RouterConfigResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RouterConfigResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersConfigsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove the config assignment on the router. The config itself will still exist. The router will no longer  get its config from the cloud, and its config may be changed in the Starlink app or via factory reset.
pub async fn enterprise_v1_account_account_number_routers_router_id_config_delete(configuration: &configuration::Configuration, account_number: &str, router_id: &str) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersRouterIdConfigDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_router_id = router_id;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/{routerId}/config", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), routerId=crate::apis::urlencode(p_router_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersRouterIdConfigDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Assign the config to the router. If the router is currently online, the config will immediately be sent to the router.  Else, the config will be sent to the router when it comes online. Configs are sent to the router within 1-2 minutes.
pub async fn enterprise_v1_account_account_number_routers_router_id_config_put(configuration: &configuration::Configuration, account_number: &str, router_id: &str, body: Option<&str>) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersRouterIdConfigPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_router_id = router_id;
    let p_body = body;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/{routerId}/config", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), routerId=crate::apis::urlencode(p_router_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersRouterIdConfigPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// @permission [RequireCustomerPermission] feature:DeviceCommand, permission:View
pub async fn enterprise_v1_account_account_number_routers_router_id_get(configuration: &configuration::Configuration, account_number: &str, router_id: &str) -> Result<models::RouterResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersRouterIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_router_id = router_id;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/{routerId}", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), routerId=crate::apis::urlencode(p_router_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RouterResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RouterResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersRouterIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// @permission [RequireCustomerPermission] feature:DeviceCommand, permission:Edit
pub async fn enterprise_v1_account_account_number_routers_router_id_reboot_post(configuration: &configuration::Configuration, account_number: &str, router_id: &str) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersRouterIdRebootPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_router_id = router_id;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/{routerId}/reboot", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), routerId=crate::apis::urlencode(p_router_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersRouterIdRebootPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the sandbox state for a client. If sandboxing is enabled, sanboxed client will only have access  to domains in the sandbox domain allow list.
pub async fn enterprise_v1_account_account_number_routers_sandbox_client_post(configuration: &configuration::Configuration, account_number: &str, update_sandbox_client_request: Option<models::UpdateSandboxClientRequest>) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersSandboxClientPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_update_sandbox_client_request = update_sandbox_client_request;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/sandbox/client", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_update_sandbox_client_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersSandboxClientPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns clients that were unsandboxed through the management API and have access that  has not yet expired. Clients that are allowed internet access due to sandbox disablement  are not returned.
pub async fn enterprise_v1_account_account_number_routers_sandbox_clients_get(configuration: &configuration::Configuration, account_number: &str, sandbox_id: Option<i32>, expiry_after: Option<String>, page: Option<i32>, limit: Option<i32>) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersSandboxClientsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_sandbox_id = sandbox_id;
    let p_expiry_after = expiry_after;
    let p_page = page;
    let p_limit = limit;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/sandbox/clients", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_sandbox_id {
        req_builder = req_builder.query(&[("sandboxId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_expiry_after {
        req_builder = req_builder.query(&[("expiryAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersSandboxClientsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the sandbox state for multiple clients. If sandboxing is enabled, sandboxed clients will only have access  to domains in the sandbox domain allow list.
pub async fn enterprise_v1_account_account_number_routers_sandbox_clients_post(configuration: &configuration::Configuration, account_number: &str, update_batch_sandbox_client_request: Option<Vec<models::UpdateBatchSandboxClientRequest>>) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersSandboxClientsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_update_batch_sandbox_client_request = update_batch_sandbox_client_request;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/sandbox/clients", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_update_batch_sandbox_client_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersSandboxClientsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Heartbeats verify the health of enterprise systems that manage router sandboxing.  If heartbeats are not received for an account, Starlink API will instruct routers  under the account disable sandboxes until reboot.
pub async fn enterprise_v1_account_account_number_routers_sandbox_heartbeat_put(configuration: &configuration::Configuration, account_number: &str, sandbox_heartbeat_request: Option<models::SandboxHeartbeatRequest>) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersSandboxHeartbeatPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_sandbox_heartbeat_request = sandbox_heartbeat_request;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/sandbox/heartbeat", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_sandbox_heartbeat_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersSandboxHeartbeatPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable or disable a client sandbox. This applies to all router configs the sandbox ID is present in.
pub async fn enterprise_v1_account_account_number_routers_sandbox_sandbox_id_put(configuration: &configuration::Configuration, account_number: &str, sandbox_id: i32, update_sandbox_request: Option<models::UpdateSandboxRequest>) -> Result<models::UpdateSandboxResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersSandboxSandboxIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_sandbox_id = sandbox_id;
    let p_update_sandbox_request = update_sandbox_request;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/sandbox/{sandboxId}", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), sandboxId=p_sandbox_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_update_sandbox_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateSandboxResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateSandboxResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersSandboxSandboxIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn enterprise_v1_account_account_number_routers_tls_config_delete(configuration: &configuration::Configuration, account_number: &str, body: Option<&str>) -> Result<models::TlsConfigPublicResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersTlsConfigDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_body = body;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/tls-config", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TlsConfigPublicResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TlsConfigPublicResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersTlsConfigDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Tls configurations can be used by routers to host a HTTPS server.
pub async fn enterprise_v1_account_account_number_routers_tls_config_post(configuration: &configuration::Configuration, account_number: &str, tls_config_create_request: Option<models::TlsConfigCreateRequest>) -> Result<models::TlsConfigPublicResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersTlsConfigPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_tls_config_create_request = tls_config_create_request;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/tls-config", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_tls_config_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TlsConfigPublicResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TlsConfigPublicResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersTlsConfigPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn enterprise_v1_account_account_number_routers_tls_configs_get(configuration: &configuration::Configuration, account_number: &str, domain: Option<&str>) -> Result<models::TlsConfigPublicResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberRoutersTlsConfigsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_domain = domain;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/routers/tls-configs", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_domain {
        req_builder = req_builder.query(&[("domain", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TlsConfigPublicResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TlsConfigPublicResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberRoutersTlsConfigsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

