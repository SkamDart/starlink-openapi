/*
 * Starlink Enterprise API
 *
 * <h3>Description</h3>API to manage accounts and user terminals. This page is deprecated, please use the new documentation site: <a href='https://starlink.readme.io/'>https://starlink.readme.io/</a><h3>Authentication - OIDC</h3><p>To authenticate with this API using OIDC, <a target='_blank' href='/api/auth/.well-known/openid-configuration'>Well Known URL</a> and attach the result to your requests with the <strong>Authorize</strong> button below.</p>
 *
 * The version of the OpenAPI document: 1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`enterprise_v1_account_account_number_user_terminals_batch_config_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberUserTerminalsBatchConfigPutError {
    Status422(models::ServiceResponse),
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_user_terminals_device_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberUserTerminalsDeviceIdDeleteError {
    Status401(),
    Status422(models::ServiceResponse),
    Status403(models::UserLacksRequiredPermissionServiceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_user_terminals_device_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberUserTerminalsDeviceIdPostError {
    Status403(),
    Status422(models::ServiceResponse),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_user_terminals_device_id_reboot_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberUserTerminalsDeviceIdRebootPostError {
    Status403(),
    Status422(models::ServiceResponse),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_user_terminals_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberUserTerminalsGetError {
    Status403(),
    Status422(models::UserTerminalResponsePaginatedServiceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_user_terminals_user_terminal_id_service_line_number_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberUserTerminalsUserTerminalIdServiceLineNumberDeleteError {
    Status403(),
    Status422(models::ServiceResponse),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_user_terminals_user_terminal_id_service_line_number_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberUserTerminalsUserTerminalIdServiceLineNumberPostError {
    Status403(),
    Status422(models::ServiceResponse),
    Status401(String),
    UnknownValue(serde_json::Value),
}


/// Assign the config (or none) to the user terminals. For each terminal if it is currently online, the config will immediately be  sent. Else, the config will be sent when it comes online. On error no assignment occurs.
pub async fn enterprise_v1_account_account_number_user_terminals_batch_config_put(configuration: &configuration::Configuration, account_number: &str, update_batch_device_config_request: Option<models::UpdateBatchDeviceConfigRequest>) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberUserTerminalsBatchConfigPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_update_batch_device_config_request = update_batch_device_config_request;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/user-terminals/batch-config", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_update_batch_device_config_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberUserTerminalsBatchConfigPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove a user terminal from the account.
pub async fn enterprise_v1_account_account_number_user_terminals_device_id_delete(configuration: &configuration::Configuration, account_number: &str, device_id: &str) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberUserTerminalsDeviceIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_device_id = device_id;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/user-terminals/{deviceId}", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), deviceId=crate::apis::urlencode(p_device_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberUserTerminalsDeviceIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add a user terminal to an account. This will add the user terminal to the account, but won't start service.
pub async fn enterprise_v1_account_account_number_user_terminals_device_id_post(configuration: &configuration::Configuration, account_number: &str, device_id: &str) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberUserTerminalsDeviceIdPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_device_id = device_id;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/user-terminals/{deviceId}", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), deviceId=crate::apis::urlencode(p_device_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberUserTerminalsDeviceIdPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// @permission [RequireCustomerPermission] feature:DeviceCommand, permission:Edit
pub async fn enterprise_v1_account_account_number_user_terminals_device_id_reboot_post(configuration: &configuration::Configuration, account_number: &str, device_id: &str) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberUserTerminalsDeviceIdRebootPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_device_id = device_id;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/user-terminals/{deviceId}/reboot", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), deviceId=crate::apis::urlencode(p_device_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberUserTerminalsDeviceIdRebootPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn enterprise_v1_account_account_number_user_terminals_get(configuration: &configuration::Configuration, account_number: &str, service_line_numbers: Option<Vec<String>>, user_terminal_ids: Option<Vec<String>>, has_service_line: Option<bool>, active: Option<bool>, search_string: Option<&str>, limit: Option<i32>, page: Option<i32>) -> Result<models::UserTerminalResponsePaginatedServiceResponse, Error<EnterpriseV1AccountAccountNumberUserTerminalsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_service_line_numbers = service_line_numbers;
    let p_user_terminal_ids = user_terminal_ids;
    let p_has_service_line = has_service_line;
    let p_active = active;
    let p_search_string = search_string;
    let p_limit = limit;
    let p_page = page;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/user-terminals", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_service_line_numbers {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("serviceLineNumbers".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("serviceLineNumbers", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_user_terminal_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("userTerminalIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("userTerminalIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_has_service_line {
        req_builder = req_builder.query(&[("hasServiceLine", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_active {
        req_builder = req_builder.query(&[("active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search_string {
        req_builder = req_builder.query(&[("searchString", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserTerminalResponsePaginatedServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserTerminalResponsePaginatedServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberUserTerminalsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove a user terminal from a service line.
pub async fn enterprise_v1_account_account_number_user_terminals_user_terminal_id_service_line_number_delete(configuration: &configuration::Configuration, account_number: &str, user_terminal_id: &str, service_line_number: &str) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberUserTerminalsUserTerminalIdServiceLineNumberDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_user_terminal_id = user_terminal_id;
    let p_service_line_number = service_line_number;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/user-terminals/{userTerminalId}/{serviceLineNumber}", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), userTerminalId=crate::apis::urlencode(p_user_terminal_id), serviceLineNumber=crate::apis::urlencode(p_service_line_number));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberUserTerminalsUserTerminalIdServiceLineNumberDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add a user terminal to a service line.
pub async fn enterprise_v1_account_account_number_user_terminals_user_terminal_id_service_line_number_post(configuration: &configuration::Configuration, account_number: &str, user_terminal_id: &str, service_line_number: &str) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberUserTerminalsUserTerminalIdServiceLineNumberPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_user_terminal_id = user_terminal_id;
    let p_service_line_number = service_line_number;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/user-terminals/{userTerminalId}/{serviceLineNumber}", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), userTerminalId=crate::apis::urlencode(p_user_terminal_id), serviceLineNumber=crate::apis::urlencode(p_service_line_number));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberUserTerminalsUserTerminalIdServiceLineNumberPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

