/*
 * Starlink Enterprise API
 *
 * <h3>Description</h3>API to manage accounts and user terminals. This page is deprecated, please use the new documentation site: <a href='https://starlink.readme.io/'>https://starlink.readme.io/</a><h3>Authentication - OIDC</h3><p>To authenticate with this API using OIDC, <a target='_blank' href='/api/auth/.well-known/openid-configuration'>Well Known URL</a> and attach the result to your requests with the <strong>Authorize</strong> button below.</p>
 *
 * The version of the OpenAPI document: 1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`enterprise_v1_account_account_number_service_lines_available_products_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberServiceLinesAvailableProductsGetError {
    Status400(),
    Status404(models::SubscriptionProductResponsePaginatedServiceResponse),
    Status422(models::SubscriptionProductResponsePaginatedServiceResponse),
    Status401(String),
    Status403(models::UserLacksRequiredPermissionServiceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_service_lines_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberServiceLinesGetError {
    Status403(),
    Status422(models::ServiceLineResponsePaginatedServiceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_service_lines_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberServiceLinesPostError {
    Status403(),
    Status422(models::ServiceLineResponseServiceResponse),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_service_lines_service_line_number_billing_cycle_all_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberBillingCycleAllGetError {
    Status403(),
    Status404(),
    Status422(models::ServiceResponse),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_service_lines_service_line_number_billing_cycle_partial_periods_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberBillingCyclePartialPeriodsGetError {
    Status403(),
    Status404(),
    Status422(models::ServiceResponse),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_service_lines_service_line_number_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberDeleteError {
    Status403(),
    Status422(models::ServiceResponse),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_service_lines_service_line_number_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberGetError {
    Status403(),
    Status422(models::ServiceLineResponseServiceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_service_lines_service_line_number_nickname_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberNicknamePutError {
    Status400(models::ServiceResponse),
    Status422(models::ServiceResponse),
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_service_lines_service_line_number_opt_in_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberOptInPostError {
    Status403(),
    Status422(models::OptInPeriodResponseServiceResponse),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_service_lines_service_line_number_opt_out_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberOptOutDeleteError {
    Status403(),
    Status422(models::OptInPeriodResponseServiceResponse),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_service_lines_service_line_number_product_product_reference_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberProductProductReferenceIdPostError {
    Status400(models::ServiceResponse),
    Status422(models::ServiceResponse),
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_service_lines_service_line_number_product_product_reference_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberProductProductReferenceIdPutError {
    Status400(models::ServiceResponse),
    Status422(models::ServiceResponse),
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_service_lines_service_line_number_public_ip_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberPublicIpPutError {
    Status400(models::ServiceResponse),
    Status422(models::ServiceResponse),
    Status403(),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_service_lines_service_line_number_recurring_data_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberRecurringDataPutError {
    Status403(),
    Status422(models::ServiceResponse),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_account_account_number_service_lines_service_line_number_top_up_data_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberTopUpDataPostError {
    Status403(),
    Status422(models::ServiceResponse),
    Status401(String),
    UnknownValue(serde_json::Value),
}


/// @permission [RequireCustomerPermission] feature:ServicePlan, permission:View
pub async fn enterprise_v1_account_account_number_service_lines_available_products_get(configuration: &configuration::Configuration, account_number: &str, limit: Option<i32>, page: Option<i32>) -> Result<models::SubscriptionProductResponsePaginatedServiceResponse, Error<EnterpriseV1AccountAccountNumberServiceLinesAvailableProductsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_limit = limit;
    let p_page = page;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/service-lines/available-products", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubscriptionProductResponsePaginatedServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubscriptionProductResponsePaginatedServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberServiceLinesAvailableProductsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn enterprise_v1_account_account_number_service_lines_get(configuration: &configuration::Configuration, account_number: &str, address_reference_id: Option<&str>, search_string: Option<&str>, limit: Option<i32>, page: Option<i32>, order_by_created_date_descending: Option<bool>) -> Result<models::ServiceLineResponsePaginatedServiceResponse, Error<EnterpriseV1AccountAccountNumberServiceLinesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_address_reference_id = address_reference_id;
    let p_search_string = search_string;
    let p_limit = limit;
    let p_page = page;
    let p_order_by_created_date_descending = order_by_created_date_descending;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/service-lines", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_address_reference_id {
        req_builder = req_builder.query(&[("addressReferenceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search_string {
        req_builder = req_builder.query(&[("searchString", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by_created_date_descending {
        req_builder = req_builder.query(&[("orderByCreatedDateDescending", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceLineResponsePaginatedServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceLineResponsePaginatedServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberServiceLinesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a service line. This must be linked to an address and a subscription/product-ID.
pub async fn enterprise_v1_account_account_number_service_lines_post(configuration: &configuration::Configuration, account_number: &str, service_line_create_request: Option<models::ServiceLineCreateRequest>) -> Result<models::ServiceLineResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberServiceLinesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_service_line_create_request = service_line_create_request;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/service-lines", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_service_line_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceLineResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceLineResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberServiceLinesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// @permission [RequireCustomerPermission] feature:DeviceTelemetry, permission:View
pub async fn enterprise_v1_account_account_number_service_lines_service_line_number_billing_cycle_all_get(configuration: &configuration::Configuration, account_number: &str, service_line_number: &str, include_unknown_data_bin: Option<bool>) -> Result<models::DataUsageResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberBillingCycleAllGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_service_line_number = service_line_number;
    let p_include_unknown_data_bin = include_unknown_data_bin;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/service-lines/{serviceLineNumber}/billing-cycle/all", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), serviceLineNumber=crate::apis::urlencode(p_service_line_number));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_unknown_data_bin {
        req_builder = req_builder.query(&[("includeUnknownDataBin", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DataUsageResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DataUsageResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberBillingCycleAllGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the previous partial periods for this service line. For more information about this endpoint, see https://starlink.readme.io/docs/understanding-proration.
pub async fn enterprise_v1_account_account_number_service_lines_service_line_number_billing_cycle_partial_periods_get(configuration: &configuration::Configuration, account_number: &str, service_line_number: &str) -> Result<models::PartialPeriodResponseIEnumerableServiceResponse, Error<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberBillingCyclePartialPeriodsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_service_line_number = service_line_number;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/service-lines/{serviceLineNumber}/billing-cycle/partial-periods", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), serviceLineNumber=crate::apis::urlencode(p_service_line_number));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PartialPeriodResponseIEnumerableServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PartialPeriodResponseIEnumerableServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberBillingCyclePartialPeriodsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// @permission [RequireCustomerPermission] feature:ServicePlan, permission:Edit
pub async fn enterprise_v1_account_account_number_service_lines_service_line_number_delete(configuration: &configuration::Configuration, account_number: &str, service_line_number: &str, reason_for_cancellation: Option<&str>, end_now: Option<bool>) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_service_line_number = service_line_number;
    let p_reason_for_cancellation = reason_for_cancellation;
    let p_end_now = end_now;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/service-lines/{serviceLineNumber}", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), serviceLineNumber=crate::apis::urlencode(p_service_line_number));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_reason_for_cancellation {
        req_builder = req_builder.query(&[("reasonForCancellation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_now {
        req_builder = req_builder.query(&[("endNow", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn enterprise_v1_account_account_number_service_lines_service_line_number_get(configuration: &configuration::Configuration, account_number: &str, service_line_number: &str) -> Result<models::ServiceLineResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_service_line_number = service_line_number;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/service-lines/{serviceLineNumber}", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), serviceLineNumber=crate::apis::urlencode(p_service_line_number));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceLineResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceLineResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// @permission [RequireCustomerPermission] feature:DeviceManagement, permission:Edit
pub async fn enterprise_v1_account_account_number_service_lines_service_line_number_nickname_put(configuration: &configuration::Configuration, account_number: &str, service_line_number: &str, service_line_update_nickname_request: Option<models::ServiceLineUpdateNicknameRequest>) -> Result<models::ServiceLineResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberNicknamePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_service_line_number = service_line_number;
    let p_service_line_update_nickname_request = service_line_update_nickname_request;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/service-lines/{serviceLineNumber}/nickname", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), serviceLineNumber=crate::apis::urlencode(p_service_line_number));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_service_line_update_nickname_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceLineResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceLineResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberNicknamePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Opt in the service line to continue using priority data after reaching the plan capacity.  Only applies to some products.
pub async fn enterprise_v1_account_account_number_service_lines_service_line_number_opt_in_post(configuration: &configuration::Configuration, account_number: &str, service_line_number: &str) -> Result<models::OptInPeriodResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberOptInPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_service_line_number = service_line_number;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/service-lines/{serviceLineNumber}/opt-in", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), serviceLineNumber=crate::apis::urlencode(p_service_line_number));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OptInPeriodResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OptInPeriodResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberOptInPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Opt out the service line. If the service line reaches the plan capacity, it will switch to using standard data.  Only applies to some products.
pub async fn enterprise_v1_account_account_number_service_lines_service_line_number_opt_out_delete(configuration: &configuration::Configuration, account_number: &str, service_line_number: &str) -> Result<models::OptInPeriodResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberOptOutDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_service_line_number = service_line_number;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/service-lines/{serviceLineNumber}/opt-out", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), serviceLineNumber=crate::apis::urlencode(p_service_line_number));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OptInPeriodResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OptInPeriodResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberOptOutDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// @permission [RequireCustomerPermission] feature:ServicePlan, permission:Edit
pub async fn enterprise_v1_account_account_number_service_lines_service_line_number_product_product_reference_id_post(configuration: &configuration::Configuration, account_number: &str, service_line_number: &str, product_reference_id: &str, set_recurring_data_blocks_request: Option<models::SetRecurringDataBlocksRequest>) -> Result<models::ServiceLineResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberProductProductReferenceIdPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_service_line_number = service_line_number;
    let p_product_reference_id = product_reference_id;
    let p_set_recurring_data_blocks_request = set_recurring_data_blocks_request;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/service-lines/{serviceLineNumber}/product/{productReferenceId}", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), serviceLineNumber=crate::apis::urlencode(p_service_line_number), productReferenceId=crate::apis::urlencode(p_product_reference_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_set_recurring_data_blocks_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceLineResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceLineResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberProductProductReferenceIdPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// @permission [RequireCustomerPermission] feature:ServicePlan, permission:Edit
pub async fn enterprise_v1_account_account_number_service_lines_service_line_number_product_product_reference_id_put(configuration: &configuration::Configuration, account_number: &str, service_line_number: &str, product_reference_id: &str) -> Result<models::ServiceLineResponseServiceResponse, Error<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberProductProductReferenceIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_service_line_number = service_line_number;
    let p_product_reference_id = product_reference_id;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/service-lines/{serviceLineNumber}/product/{productReferenceId}", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), serviceLineNumber=crate::apis::urlencode(p_service_line_number), productReferenceId=crate::apis::urlencode(p_product_reference_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceLineResponseServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceLineResponseServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberProductProductReferenceIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// @permission [RequireCustomerPermission] feature:ServicePlan, permission:Edit
pub async fn enterprise_v1_account_account_number_service_lines_service_line_number_public_ip_put(configuration: &configuration::Configuration, account_number: &str, service_line_number: &str, service_line_set_public_ip_request: Option<models::ServiceLineSetPublicIpRequest>) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberPublicIpPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_service_line_number = service_line_number;
    let p_service_line_set_public_ip_request = service_line_set_public_ip_request;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/service-lines/{serviceLineNumber}/public-ip", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), serviceLineNumber=crate::apis::urlencode(p_service_line_number));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_service_line_set_public_ip_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberPublicIpPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// @permission [RequireCustomerPermission] feature:ServicePlan, permission:Edit
pub async fn enterprise_v1_account_account_number_service_lines_service_line_number_recurring_data_put(configuration: &configuration::Configuration, account_number: &str, service_line_number: &str, set_recurring_data_blocks_request: Option<models::SetRecurringDataBlocksRequest>) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberRecurringDataPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_service_line_number = service_line_number;
    let p_set_recurring_data_blocks_request = set_recurring_data_blocks_request;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/service-lines/{serviceLineNumber}/recurring-data", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), serviceLineNumber=crate::apis::urlencode(p_service_line_number));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_set_recurring_data_blocks_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberRecurringDataPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// @permission [RequireCustomerPermission] feature:ServicePlan, permission:Edit
pub async fn enterprise_v1_account_account_number_service_lines_service_line_number_top_up_data_post(configuration: &configuration::Configuration, account_number: &str, service_line_number: &str, public_add_data_block_request: Option<models::PublicAddDataBlockRequest>) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberTopUpDataPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_service_line_number = service_line_number;
    let p_public_add_data_block_request = public_add_data_block_request;

    let uri_str = format!("{}/enterprise/v1/account/{accountNumber}/service-lines/{serviceLineNumber}/top-up-data", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number), serviceLineNumber=crate::apis::urlencode(p_service_line_number));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_public_add_data_block_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountAccountNumberServiceLinesServiceLineNumberTopUpDataPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

