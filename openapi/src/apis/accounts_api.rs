/*
 * Starlink Enterprise API
 *
 * <h3>Description</h3>API to manage accounts and user terminals. This page is deprecated, please use the new documentation site: <a href='https://starlink.readme.io/'>https://starlink.readme.io/</a><h3>Authentication - OIDC</h3><p>To authenticate with this API using OIDC, <a target='_blank' href='/api/auth/.well-known/openid-configuration'>Well Known URL</a> and attach the result to your requests with the <strong>Authorize</strong> button below.</p>
 *
 * The version of the OpenAPI document: 1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`enterprise_v1_accounts_account_number_billing_cycles_query_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountsAccountNumberBillingCyclesQueryPostError {
    Status403(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_accounts_account_number_router_local_content_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountsAccountNumberRouterLocalContentGetError {
    Status403(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_accounts_account_number_router_local_content_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountsAccountNumberRouterLocalContentPostError {
    Status403(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_accounts_account_number_update_default_router_config_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountsAccountNumberUpdateDefaultRouterConfigPutError {
    Status403(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_accounts_account_number_update_default_router_tls_domain_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountsAccountNumberUpdateDefaultRouterTlsDomainPutError {
    Status403(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enterprise_v1_accounts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnterpriseV1AccountsGetError {
    Status403(),
    Status422(models::AccountResponsePaginatedServiceResponse),
    UnknownValue(serde_json::Value),
}


/// Retrieve the real-time data tracking system for an account's data usage data.  For detailed instructions, please refer to the API documentation: https://starlink.readme.io/docs/data-usage-api
pub async fn enterprise_v1_accounts_account_number_billing_cycles_query_post(configuration: &configuration::Configuration, account_number: &str, query_billing_cycle_request: Option<models::QueryBillingCycleRequest>) -> Result<models::ServiceLineDataUsageForBillingCyclesPaginatedServiceResponse, Error<EnterpriseV1AccountsAccountNumberBillingCyclesQueryPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_query_billing_cycle_request = query_billing_cycle_request;

    let uri_str = format!("{}/enterprise/v1/accounts/{accountNumber}/billing-cycles/query", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_query_billing_cycle_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceLineDataUsageForBillingCyclesPaginatedServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceLineDataUsageForBillingCyclesPaginatedServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountsAccountNumberBillingCyclesQueryPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn enterprise_v1_accounts_account_number_router_local_content_get(configuration: &configuration::Configuration, account_number: &str) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountsAccountNumberRouterLocalContentGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;

    let uri_str = format!("{}/enterprise/v1/accounts/{accountNumber}/router-local-content", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountsAccountNumberRouterLocalContentGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Upload html file to allow it to be configured as the HTTPS server local content file for router configs.  File should be attached as multipart/form-data.  See https://starlink.readme.io/docs/local-content for example upload script.
pub async fn enterprise_v1_accounts_account_number_router_local_content_post(configuration: &configuration::Configuration, account_number: &str, file: std::path::PathBuf) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountsAccountNumberRouterLocalContentPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_file = file;

    let uri_str = format!("{}/enterprise/v1/accounts/{accountNumber}/router-local-content", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'File' parameter
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountsAccountNumberRouterLocalContentPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set the default router config on the account. Use an empty string to remove the default  config from the account. Any new routers on this account will be assigned this config.
pub async fn enterprise_v1_accounts_account_number_update_default_router_config_put(configuration: &configuration::Configuration, account_number: &str, update_default_config_request: Option<models::UpdateDefaultConfigRequest>) -> Result<models::AccountResponsePaginatedServiceResponse, Error<EnterpriseV1AccountsAccountNumberUpdateDefaultRouterConfigPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_update_default_config_request = update_default_config_request;

    let uri_str = format!("{}/enterprise/v1/accounts/{accountNumber}/update-default-router-config", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_update_default_config_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountResponsePaginatedServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountResponsePaginatedServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountsAccountNumberUpdateDefaultRouterConfigPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set the default tls domain for routers under the account. Use an empty string to remove the default from the account.  By default, all routers on this account will host a HTTPS server at this domain.  A tls config must exist for this domain.
pub async fn enterprise_v1_accounts_account_number_update_default_router_tls_domain_put(configuration: &configuration::Configuration, account_number: &str, update_default_router_tls_request: Option<models::UpdateDefaultRouterTlsRequest>) -> Result<models::ServiceResponse, Error<EnterpriseV1AccountsAccountNumberUpdateDefaultRouterTlsDomainPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_number = account_number;
    let p_update_default_router_tls_request = update_default_router_tls_request;

    let uri_str = format!("{}/enterprise/v1/accounts/{accountNumber}/update-default-router-tls-domain", configuration.base_path, accountNumber=crate::apis::urlencode(p_account_number));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_update_default_router_tls_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountsAccountNumberUpdateDefaultRouterTlsDomainPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get paginated accounts of the current authenticated user.
pub async fn enterprise_v1_accounts_get(configuration: &configuration::Configuration, region_code: Option<Vec<String>>, limit: Option<i32>, page: Option<i32>) -> Result<models::AccountResponsePaginatedServiceResponse, Error<EnterpriseV1AccountsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_region_code = region_code;
    let p_limit = limit;
    let p_page = page;

    let uri_str = format!("{}/enterprise/v1/accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_region_code {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("regionCode".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("regionCode", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountResponsePaginatedServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountResponsePaginatedServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnterpriseV1AccountsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

